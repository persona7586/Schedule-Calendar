<!-- templates/auto_subtitle.html -->
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>자동 자막 추출</title>
  <style>
    body { font-family: sans-serif; margin:0; padding:1em; }
    #controls { text-align:center; margin-bottom:1em; }
    #controls button { margin:0 .3em; padding:.5em 1em; cursor:pointer; }

    #video-container {
      position: relative;
      width: 80%; max-width:1200px;
      height: 450px; margin:0 auto 1em;
      border:1px solid #ccc; background:#000;
      overflow:hidden;
    }
    #screen-video {
      position:absolute; top:0; left:0;
      width:100%; height:100%;
      object-fit:contain;
      pointer-events:none; z-index:1;
    }
    #overlay {
      position:absolute; top:0; left:0;
      width:100%; height:100%;
      background:rgba(0,0,0,0.1);
      cursor:crosshair;
      display:none; z-index:2;
    }
    #selection-rect {
      position:absolute; border:2px dashed lime;
      display:none; z-index:3;
    }

    /* 디버그용 프리뷰 캔버스 */
    #debug-canvas {
      display:block; margin:1em auto;
      border:2px solid red;
    }

    #real-time-sub {
      width:80%; max-width:1200px; height:200px;
      margin:0 auto; display:block;
      border:1px solid #999; font-family:monospace;
      padding:.5em; resize:none;
    }
  </style>

  <!-- Tesseract.js CDN -->
  <script src="https://unpkg.com/tesseract.js@2/dist/tesseract.min.js"></script>
</head>
<body>
  <h1 style="text-align:center;">자동 자막 추출</h1>
  <div id="controls">
    <button id="btn-share">화면 공유 시작</button>
    <button id="btn-select">영역 선택 모드</button>
    <button id="btn-ocr-toggle" style="background:#28a745;color:#fff;">
      자막 추출 시작
    </button>
    <button id="btn-clear">자막 초기화</button>
  </div>

  <div id="video-container">
    <video id="screen-video" autoplay></video>
    <div id="overlay"></div>
    <div id="selection-rect"></div>
  </div>

  <!-- 디버그: 잘린 영역 미리보기 -->
  <canvas id="debug-canvas" width="0" height="0"></canvas>

  <h2 style="text-align:center;">실시간 자막</h2>
  <textarea id="real-time-sub" readonly></textarea>

  <script>
  window.addEventListener('DOMContentLoaded', () => {
    const btnShare  = document.getElementById('btn-share');
    const btnSelect = document.getElementById('btn-select');
    const btnOcr    = document.getElementById('btn-ocr-toggle');
    const btnClear  = document.getElementById('btn-clear');

    const video    = document.getElementById('screen-video');
    const overlay  = document.getElementById('overlay');
    const rectDiv  = document.getElementById('selection-rect');
    const debugCv  = document.getElementById('debug-canvas');
    const debugCtx = debugCv.getContext('2d');
    const subBox   = document.getElementById('real-time-sub');

    let selecting = false;
    let startX=0, startY=0;
    let rect = { x:0, y:0, w:0, h:0 };
    let ocrInterval = null;

    let prevText = '';

    // 1) 화면 공유 시작
    btnShare.onclick = async () => {
      const stream = await navigator.mediaDevices.getDisplayMedia({ video:true });
      video.srcObject = stream;
      await video.play();
    };

    // 2) 영역 선택 모드
    btnSelect.onclick = () => {
      selecting = true;
      overlay.style.display = 'block';
      rectDiv.style.display = 'none';
    };

    // 3) 드래그 → 영역 고정
    overlay.addEventListener('mousedown', e => {
      if (!selecting) return;
      const b = overlay.getBoundingClientRect();
      startX = e.clientX - b.left;
      startY = e.clientY - b.top;
      rectDiv.style.left   = startX + 'px';
      rectDiv.style.top    = startY + 'px';
      rectDiv.style.width  = '0px';
      rectDiv.style.height = '0px';
      rectDiv.style.display= 'block';

      const onMove = ev => {
        const cx = ev.clientX - b.left;
        const cy = ev.clientY - b.top;
        const x = Math.min(startX,cx), y = Math.min(startY,cy);
        const w = Math.abs(cx-startX), h = Math.abs(cy-startY);
        Object.assign(rectDiv.style, { left:x+'px', top:y+'px', width:w+'px', height:h+'px' });
      };
      const onUp = ev => {
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);
        overlay.style.display = 'none';
        selecting = false;
        const ex = ev.clientX - b.left, ey = ev.clientY - b.top;
        rect = {
          x: Math.min(startX,ex),
          y: Math.min(startY,ey),
          w: Math.abs(ex-startX),
          h: Math.abs(ey-startY)
        };
      };
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup',   onUp);
    });

    // 4) OCR 시작/중단
    btnOcr.onclick = () => {
      if (!ocrInterval) {
        if (rect.w===0 || rect.h===0) {
          alert('먼저 영역을 드래그로 선택하세요.');
          return;
        }
        btnOcr.textContent      = '자막 추출 중단';
        btnOcr.style.background = '#dc3545';

        const vb     = video.getBoundingClientRect();
        const vidAR  = video.videoWidth / video.videoHeight;
        // 렌더된 비디오 실제 영역 계산
        let renderW, renderH, offsetX, offsetY;
        if (vb.width / vb.height > vidAR) {
          renderH = vb.height;
          renderW = renderH * vidAR;
          offsetX = (vb.width - renderW)/2;
          offsetY = 0;
        } else {
          renderW = vb.width;
          renderH = renderW / vidAR;
          offsetX = 0;
          offsetY = (vb.height - renderH)/2;
        }

        ocrInterval = setInterval(async () => {
          // ① 원본 영상 픽셀 좌표 보정
          const sx = (rect.x - offsetX) * (video.videoWidth  / renderW);
          const sy = (rect.y - offsetY) * (video.videoHeight / renderH);
          const sw = rect.w * (video.videoWidth  / renderW);
          const sh = rect.h * (video.videoHeight / renderH);

          // ② 캔버스 해상도 & 크기 설정
          const dpr = window.devicePixelRatio || 1;
          debugCv.width        = sw * dpr;
          debugCv.height       = sh * dpr;
          debugCv.style.width  = `${rect.w}px`;
          debugCv.style.height = `${rect.h}px`;
          debugCtx.setTransform(dpr,0,0,dpr,0,0);

          // ③ 잘라낸 프레임 그리기
          debugCtx.clearRect(0,0,sw,sh);
          debugCtx.drawImage(video, sx,sy, sw,sh, 0,0, sw,sh);

          // ④ 간단 전처리(이진화)
          const img = debugCtx.getImageData(0,0,sw,sh);
          for (let i=0; i<img.data.length; i+=4) {
            const gray = (img.data[i]+img.data[i+1]+img.data[i+2])/3;
            const v = gray>128?255:0;
            img.data[i]=img.data[i+1]=img.data[i+2]=v;
          }
          debugCtx.putImageData(img,0,0);

          // ⑤ OCR(kor+eng, 특수문자 포함)
          const { data:{ text }} = await Tesseract.recognize(
            debugCv,
            'kor+eng',
            {
              tessedit_char_whitelist: '가-힣A-Za-z0-9[](),.?!:; ' ,
              logger: m=>{}
            }
          );

          // 2) 중복 방지 로직 (3번)
          const filtered = text.trim();
          if (filtered && filtered !== prevText) {
            prevText = filtered;
            subBox.value += filtered + '\n';
            subBox.scrollTop = subBox.scrollHeight;
          }
        }, 700);

      } else {
        clearInterval(ocrInterval);
        ocrInterval = null;
        btnOcr.textContent      = '자막 추출 시작';
        btnOcr.style.background = '#28a745';
      }
    };

    // 5) 자막 초기화
    btnClear.onclick = () => {
      subBox.value = '';
      prevText = '';     // 중복 기록 초기화 (4번)
      clearInterval(ocrInterval);
      ocrInterval = null;
      btnOcr.textContent      = '자막 추출 시작';
      btnOcr.style.background = '#28a745';
      rectDiv.style.display = 'none';
      rect = { x:0,y:0,w:0,h:0 };
    };
  });
  </script>
</body>
</html>
